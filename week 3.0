#include <Wire.h>
#include <LiquidCrystal.h>
#include <math.h>

// ===================== 管脚映射 ======================
const int IR_L_PIN = 0;    // 左 IR（数字输入，注意上传程序时必须断开）
const int IR_M_PIN = A3;   // 中 IR（数字输入）
const int IR_R_PIN = A0;   // 右 IR（数字输入）

const int ENC_R_PIN = A1;  // 右编码器
const int ENC_L_PIN = A2;  // 左编码器

#define L_PWM   11
#define R_PWM   3
#define L_IN1   1
#define L_IN2   2
#define R_IN1   12
#define R_IN2   13

LiquidCrystal lcd(8, 9, 4, 5, 6, 7);

// MPU6050 地址
const uint8_t MPU_ADDR = 0x68;

// ===================== 参数 ======================
const float wheelCirc = 4.71f;   // 轮周长 cm
const float encoderPPR = 40.0f;  // 每圈脉冲

int leftPWM  = 150;
int rightPWM = 150;

const int BASE_SPEED = 150;
const int TURN_SPEED = 140;
const int SPEED_STEP = 5;
const int SPEED_TOL_PULSE = 1;

unsigned long SPEED_ADJUST_INTERVAL = 100;

long leftEncoderCount  = 0;
long rightEncoderCount = 0;

int lastEncLState = LOW;
int lastEncRState = LOW;

float traveledDistanceCM = 0.0;
unsigned long startMillis = 0;

long lastLeftCountForSpeed  = 0;
long lastRightCountForSpeed = 0;
unsigned long lastSpeedAdjustMillis = 0;

bool stopForeverFlag = false;
bool done330Stop = false;
bool rampClimbing = false;
bool rampTopHandled = false;

const float RAMP_UP_ANGLE = 10.0;
const float RAMP_FLAT_ANGLE = 3.0;

const long TURN90_PULSES = 20;

// ===================== 函数声明 =====================
void mpuInit();
float readPitchAngle();
void updateEncoders();
void updateDistance();
void simpleSpeedAdjust();
void setMotor(int l, int r);
void stopMotor();
void rotateInPlaceDegrees(int deg, bool cw);
void lineFollowing(bool L, bool M, bool R);
void doLCD(float dist, unsigned long sec, float angle);

// ===================== 初始化 =====================
void setup() {
  pinMode(IR_L_PIN, INPUT);
  pinMode(IR_M_PIN, INPUT);
  pinMode(IR_R_PIN, INPUT);

  pinMode(ENC_L_PIN, INPUT_PULLUP);
  pinMode(ENC_R_PIN, INPUT_PULLUP);

  pinMode(L_PWM, OUTPUT);
  pinMode(R_PWM, OUTPUT);
  pinMode(L_IN1, OUTPUT);
  pinMode(L_IN2, OUTPUT);
  pinMode(R_IN1, OUTPUT);
  pinMode(R_IN2, OUTPUT);

  lcd.begin(16, 2);
  lcd.clear();
  lcd.print("Car Start");

  Wire.begin();
  mpuInit();

  lastEncLState = digitalRead(ENC_L_PIN);
  lastEncRState = digitalRead(ENC_R_PIN);

  startMillis = millis();
}

// ===================== 主循环 =====================
void loop() {
  if (stopForeverFlag) {
    stopMotor();
    delay(100);
    return;
  }

  updateEncoders();
  updateDistance();

  float pitch = readPitchAngle();
  unsigned long now = millis();
  unsigned long sec = (now - startMillis) / 1000;

  int rawL = digitalRead(IR_L_PIN);
  int rawM = digitalRead(IR_M_PIN);
  int rawR = digitalRead(IR_R_PIN);

  // 按你的逻辑：
  // 左、右：HIGH = 黑线，LOW = 白地
  // 中间：LOW = 黑线（反向逻辑）
  bool L = (rawL == HIGH);
  bool R = (rawR == HIGH);
  bool M = (rawM == LOW);

  // 全部在线 => 永久停机
  if (L && M && R) {
    stopMotor();
    doLCD(traveledDistanceCM, sec, pitch);
    stopForeverFlag = true;
    return;
  }

  // 到 330cm 停 2s（只一次）
  if (!done330Stop && traveledDistanceCM >= 330.0f) {
    stopMotor();
    doLCD(traveledDistanceCM, sec, pitch);
    delay(2000);
    done330Stop = true;
  }

  float absAng = abs(pitch);
  if (!rampClimbing && absAng > RAMP_UP_ANGLE) {
    rampClimbing = true;
  }
  if (rampClimbing && !rampTopHandled && absAng < RAMP_FLAT_ANGLE) {
    stopMotor();
    doLCD(traveledDistanceCM, sec, pitch);
    delay(4000);
    rotateInPlaceDegrees(360, true);
    rampTopHandled = true;
    rampClimbing = false;
  }

  // 全部离线 => 原地顺时针 90°
  if (!L && !M && !R) {
    rotateInPlaceDegrees(90, true);
  } else {
    lineFollowing(L, M, R);
  }

  simpleSpeedAdjust();
  setMotor(leftPWM, rightPWM);

  doLCD(traveledDistanceCM, sec, pitch);

  delay(10);
}

// ===================== MPU6050 =====================
void mpuInit() {
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x6B);
  Wire.write(0);
  Wire.endTransmission(true);
  delay(50);
}

float readPitchAngle() {
  int16_t ax, ay, az;

  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x3B);
  Wire.endTransmission(false);
  Wire.requestFrom(MPU_ADDR, 6, true);

  if (Wire.available() < 6) return 0;

  ax = (Wire.read() << 8) | Wire.read();
  ay = (Wire.read() << 8) | Wire.read();
  az = (Wire.read() << 8) | Wire.read();

  float axf = ax / 16384.0;
  float ayf = ay / 16384.0;
  float azf = az / 16384.0;

  float pitch = atan2(axf, sqrt(ayf * ayf + azf * azf)) * 180.0 / PI;
  return pitch;
}

// ===================== 编码器与距离 =====================
void updateEncoders() {
  int cl = digitalRead(ENC_L_PIN);
  int cr = digitalRead(ENC_R_PIN);

  if (cl == HIGH && lastEncLState == LOW) leftEncoderCount++;
  if (cr == HIGH && lastEncRState == LOW) rightEncoderCount++;

  lastEncLState = cl;
  lastEncRState = cr;
}

void updateDistance() {
  long avg = (leftEncoderCount + rightEncoderCount) / 2;
  traveledDistanceCM = avg * (wheelCirc / encoderPPR);
}

// ===================== 巡线控制 =====================
void lineFollowing(bool L, bool M, bool R) {
  leftPWM  = BASE_SPEED;
  rightPWM = BASE_SPEED;

  if (M && !L && !R) {
    // 中间在线，直走
  } else if (L && !M) {
    leftPWM  = BASE_SPEED - 40;
    rightPWM = BASE_SPEED + 40;
  } else if (R && !M) {
    leftPWM  = BASE_SPEED + 40;
    rightPWM = BASE_SPEED - 40;
  } else if (L && M && !R) {
    leftPWM  = BASE_SPEED - 20;
    rightPWM = BASE_SPEED + 20;
  } else if (R && M && !L) {
    leftPWM  = BASE_SPEED + 20;
    rightPWM = BASE_SPEED - 20;
  }
}

// ===================== 简单速度平衡 =====================
void simpleSpeedAdjust() {
  unsigned long now = millis();
  if (now - lastSpeedAdjustMillis < SPEED_ADJUST_INTERVAL) return;
  lastSpeedAdjustMillis = now;

  long dl = leftEncoderCount  - lastLeftCountForSpeed;
  long dr = rightEncoderCount - lastRightCountForSpeed;

  lastLeftCountForSpeed = leftEncoderCount;
  lastRightCountForSpeed = rightEncoderCount;

  if (dl == 0 && dr == 0) return;

  if (dl - dr > SPEED_TOL_PULSE) {
    leftPWM  -= SPEED_STEP;
    rightPWM += SPEED_STEP;
  } else if (dr - dl > SPEED_TOL_PULSE) {
    rightPWM -= SPEED_STEP;
    leftPWM  += SPEED_STEP;
  }

  leftPWM  = constrain(leftPWM, 0, 255);
  rightPWM = constrain(rightPWM, 0, 255);
}

// ===================== 电机控制 =====================
void setMotor(int l, int r) {
  if (l >= 0) {
    digitalWrite(L_IN1, HIGH);
    digitalWrite(L_IN2, LOW);
    analogWrite(L_PWM, l);
  } else {
    digitalWrite(L_IN1, LOW);
    digitalWrite(L_IN2, HIGH);
    analogWrite(L_PWM, -l);
  }

  if (r >= 0) {
    digitalWrite(R_IN1, HIGH);
    digitalWrite(R_IN2, LOW);
    analogWrite(R_PWM, r);
  } else {
    digitalWrite(R_IN1, LOW);
    digitalWrite(R_IN2, HIGH);
    analogWrite(R_PWM, -r);
  }
}

void stopMotor() {
  analogWrite(L_PWM, 0);
  analogWrite(R_PWM, 0);
  digitalWrite(L_IN1, LOW);
  digitalWrite(L_IN2, LOW);
  digitalWrite(R_IN1, LOW);
  digitalWrite(R_IN2, LOW);
}

// ===================== 原地旋转 =====================
void rotateInPlaceDegrees(int deg, bool cw) {
  int ls = cw ? TURN_SPEED : -TURN_SPEED;
  int rs = cw ? -TURN_SPEED : TURN_SPEED;

  long sL = leftEncoderCount;
  long sR = rightEncoderCount;

  long target = (long)((float)deg / 90.0 * TURN90_PULSES);

  setMotor(ls, rs);

  while (1) {
    updateEncoders();
    long dL = abs(leftEncoderCount - sL);
    long dR = abs(rightEncoderCount - sR);
    long avg = (dL + dR) / 2;
    if (avg >= target) break;
    delay(2);
  }

  stopMotor();
}

// ===================== LCD 显示 =====================
void doLCD(float dist, unsigned long sec, float angle) {
  lcd.setCursor(0, 0);
  lcd.print("D:");
  lcd.print((int)dist);
  lcd.print("cm ");

  lcd.print("T:");
  lcd.print(sec);
  lcd.print("s ");

  lcd.setCursor(0, 1);
  lcd.print("Ang:");
  lcd.print((int)angle);
  lcd.print("   ");
}
