#include <LiquidCrystal.h>

// ---------------- LCD ----------------
LiquidCrystal lcd(8, 9, 4, 5, 6, 7);

// ---------------- Pin å®šä¹‰ ----------------
// IR ä¼ æ„Ÿå™¨
#define IR_LEFT   A3
#define IR_MID    A2
#define IR_RIGHT  A1

// ç¼–ç å™¨
#define ENC_LEFT  A5
#define ENC_RIGHT A4

// ç”µæœº
#define L_PWM   11
#define R_PWM   3
#define L_IN1   1
#define L_IN2   2
#define R_IN1   12
#define R_IN2   13

// ---------------- å°è½¦å‚æ•° ----------------
const int baseSpeed = 120;       // é»˜è®¤ PWM é€Ÿåº¦
const float wheelCirc = 7.5;    // æ¯åœˆè½®å­å‘¨é•¿ cm
const float encoderPPR = 40;       // ç¼–ç å™¨æ¯è½¬è„‰å†²æ•°
float distance;
bool stoppedForever = false;


// ---------------- ç¼–ç å™¨è®¡æ•° ----------------
volatile long leftCount = 0;
volatile long rightCount = 0;

// ---------------- æ—¶é—´ ----------------
unsigned long startTime;

// ==================== å¼ºåˆ¶åœæ­¢ ====================
void hardStop() {
  analogWrite(L_PWM, 0);
  analogWrite(R_PWM, 0);
  digitalWrite(L_IN1, LOW);
  digitalWrite(L_IN2, LOW);
  digitalWrite(R_IN1, LOW);
  digitalWrite(R_IN2, LOW);

  stoppedForever = true;   // <-- permanently stop robot
}


// ==================== ç¼–ç å™¨ä¸­æ–­ ====================
void leftEncoderISR()  { leftCount++; }   // å·¦è½®ç¼–ç å™¨è„‰å†²åŠ 1
void rightEncoderISR() { rightCount++; }  // å³è½®ç¼–ç å™¨è„‰å†²åŠ 1

// ==================== ç”µæœºæ§åˆ¶ ====================
void setMotor(int lpwm, int rpwm) {
  // å·¦è½®
  if (lpwm >= 0) { digitalWrite(L_IN1, HIGH); digitalWrite(L_IN2, LOW); }
  else { digitalWrite(L_IN1, LOW); digitalWrite(L_IN2, HIGH); lpwm = -lpwm; }

  // å³è½®
  if (rpwm >= 0) { digitalWrite(R_IN1, HIGH); digitalWrite(R_IN2, LOW); }
  else { digitalWrite(R_IN1, LOW); digitalWrite(R_IN2, HIGH); rpwm = -rpwm; }

  analogWrite(L_PWM, constrain(lpwm, 0, 255));
  analogWrite(R_PWM, constrain(rpwm, 0, 255));
}

// ==================== speed trimï¼ˆè®©è½¦èµ°ç›´ï¼‰====================
int speedTrim() {  
  long diff = leftCount - rightCount;

  // ç®€æ˜“çº¿æ€§è¡¥å¿ï¼Œä¸ç”¨å¤ª fancyï¼Œå°è½¦å°±å–œæ¬¢æœ´å®æ— å ğŸ¤–
  return constrain(diff * 2, -70, 70);
}

// ==================== è¯»å– IR ä¼ æ„Ÿå™¨ ====================
void readIRSensors(bool &L, bool &M, bool &R) {
  L = digitalRead(IR_LEFT) == LOW;   // å·¦é»‘çº¿ä¸º LOW
  M = digitalRead(IR_MID)  == HIGH;  // ä¸­é—´ä¼ æ„Ÿå™¨é€»è¾‘åè½¬
  R = digitalRead(IR_RIGHT) == LOW;  // å³é»‘çº¿ä¸º LOW
}

float updateDist() {
  float rev = ((leftCount + rightCount) / 2.0) / encoderPPR;
  distance = rev*wheelCirc;   // <-- update global variable
  return distance;
}

// ==================== æ›´æ–° LCD ====================
void updateLCD() {

  lcd.setCursor(0, 0);
  lcd.print("Time: ");
  lcd.print((millis() - startTime) / 1000);
  lcd.print("s       ");

  lcd.setCursor(0, 1);
  lcd.print("Dist: ");
  lcd.print(distance);
  lcd.print("cm      ");
}

volatile boolean lastA4 = HIGH;
volatile boolean lastA5 = HIGH;

ISR(PCINT1_vect) {
  boolean currA4 = digitalRead(A4);
  boolean currA5 = digitalRead(A5);

  // A4 rising edge = left encoder pulse
  if (lastA4 == LOW && currA4 == HIGH) {
    leftCount++;
  }
  lastA4 = currA4;

  // A5 rising edge = right encoder pulse
  if (lastA5 == LOW && currA5 == HIGH) {
    rightCount++;
  }
  lastA5 = currA5;
}


// ==================== SETUP ====================
void setup() {
  lcd.begin(16, 2);

  pinMode(IR_LEFT,  INPUT_PULLUP);
  pinMode(IR_MID,   INPUT_PULLUP);
  pinMode(IR_RIGHT, INPUT_PULLUP);

  pinMode(ENC_LEFT,  INPUT_PULLUP);
  pinMode(ENC_RIGHT, INPUT_PULLUP);

  pinMode(L_PWM, OUTPUT);
  pinMode(R_PWM, OUTPUT);
  pinMode(L_IN1, OUTPUT);
  pinMode(L_IN2, OUTPUT);
  pinMode(R_IN1, OUTPUT);
  pinMode(R_IN2, OUTPUT);

  // ç¼–ç å™¨ä¸­æ–­
  // Enable Pin Change Interrupts on PCINT1 group (A0â€“A5)
PCICR |= (1 << PCIE1);

// Enable interrupts for PCINT20 (A4) and PCINT21 (A5)
PCMSK1 |= (1 << PCINT20) | (1 << PCINT21);

  startTime = millis();

  lcd.print("Line Car Ready!");
  delay(1500);
}

// ==================== LOOP ä¸»é€»è¾‘ ====================
void loop() {

  bool L, M, R;
  readIRSensors(L, M, R);

  int trim = speedTrim(); // ç¼–ç å™¨é€Ÿåº¦è¡¥å¿
  int leftSpeed  = baseSpeed - trim;
  int rightSpeed = baseSpeed + trim;

  // ---- å…¨é»‘åœæ­¢ ----
  if (L && M && R) {  
    hardStop();
    return;
  }

  if (stoppedForever) {
    hardStop();      // keep motors off
    updateLCD();     // still show time/dist if you want
    return;          // stop everything else FOREVER
}

  // ---- å…¨ç™½è‡ªæ—‹ ----
  static unsigned long allWhiteStart = 0;
  if (!L && !M && !R) {  
    if (allWhiteStart == 0) allWhiteStart = millis();
    if (millis() - allWhiteStart > 10) {
      setMotor(255, -255);
      return;
    }
  } else {
    allWhiteStart = 0;
  }

  // ---- å¾ªè¿¹é€»è¾‘ ----

  if (M) {
    setMotor(leftSpeed, rightSpeed); // ä¸­é—´ä¼ æ„Ÿå™¨æ£€æµ‹åˆ°é»‘çº¿ï¼Œç›´è¡Œ
  } else {
    if (L) {
      setMotor(leftSpeed - 90, rightSpeed + 90); // å·¦åï¼Œå³è½¬ä¿®æ­£
    } else if (R) {
      setMotor(leftSpeed + 90, rightSpeed - 90); // å³åï¼Œå·¦è½¬ä¿®æ­£
    }
  }

  // ---- æ›´æ–° LCD æ˜¾ç¤ºæ—¶é—´å’Œè·ç¦» ----
    updateDist();
    updateLCD();
    delay(5);

}
